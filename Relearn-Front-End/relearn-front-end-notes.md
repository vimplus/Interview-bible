# 重学前端笔记

## JavaScript
用一定的词法和语法，表达一定语义，从而操作运行时。

我们都知道：程序 = 算法 + 数据结构，那么，对运行时来说，类型就是数据结构，执行过程就是算法。

### 为什么有的编程规范要求用 void 0 代替 undefined？
> 因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。

### 字符串有最大长度吗？
> 字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。

### 0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？
> 这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值： console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);

### 为什么给对象添加的方法能用在基本类型上？
> 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。

### 对象的几个特征？
* 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。
* 对象有状态：对象具有状态，同一对象可能处于不同状态之下。
* 对象具有行为：即对象的状态，可能因为它的行为产生变迁。

对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。
JavaScript也是正统的面向对象语言。

函数对象的定义是：具有[[call]]私有字段的对象，构造器对象的定义是：具有私有字段[[construct]]的对象。

#### 对象的两类属性

数据属性：

- value：属性值
- writable：属性能否被赋值
- enumerable：可否被for in枚举
- configurable：可否被删除或改变特征值

访问器属性：

- getter：获取时调用
- setter：设置时调用
- enumerable：可否被for in枚举
- configurable：可否被删除或改变特征值

#### JavaScript和Java为代表的面向对象区别
* 以Java为代表的面向对象是基于**类**的面向对象
* JavaScript是基于**原型**的面向对象

#### 基于类与基于原型的两者差别还是很大的

* 基于类的思想先有类，再用类去实例化一个对象；
* 基于原型的思想则提倡关注实例的行为，然后才关心将这些对象划分到相似的原型对象，而不是分成类。

> 在我看来，不同语言有不同的特性，JavaScript对象具有高度动态性，因为JavaScript赋予了使用者在运行时为对象添加状态和行为的能力，比如创建一个对象后，再给它添加属性，这样毫无问题。没有必要刻意的去模拟基于类的一些方法，应该充分利用JavaScript的优秀之处。

### JavaScript 的原型
* 所有对象都有私有字段[[prototype]]，就是对象的原型；
* 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。

### New的原理
new 运算接受一个构造器和一组调用参数，实际上做了几件事：

* 以构造器的 prototype 属性（注意与私有字段[[prototype]]的区分）为原型，创建新对象；
* 将 this 和调用参数传给构造器，执行；
* 如果构造器返回的是对象，则返回这个对象，否则返回第一步创建的对象。

### 微任务与宏任务

首先，微任务和宏任务的概念来区。一个JavaScript引擎会常驻内存中，等待我们（宿主）把JavaScript代码或函数传递执行。

在之前，JavaScript本身还没有异步执行代码的能力，就意味着宿主传递给JavaScript引擎一段代码，引擎直接把代码顺序执行了，这个任务就是宿主发起的任务。在ES6引入的Promise，不需要浏览器的安排，JavaScript引擎本身也能发起任务了。

- 宏任务：这里把宿主发起的任务称为宏任务（setTimeout，setInterval）
- 微任务：JavaScript引擎发起的任务称为微任务（Promise）

总结一下，浏览器端的循环优先级，在同一个循环下：`同步` > `微任务（Promise）` > `宏任务（setTimeout，setInterval）`

### 如何分析异步执行的顺序：
* 首先我们分析有多少个宏任务；
* 在每个宏任务中，分析有多少个微任务；
* 根据调用次序，确定宏任务中的微任务执行次序；
* 根据宏任务的触发规则和调用次序，确定宏任务的执行次序；
* 确定整个顺序。

### 什么是闭包？
闭包其实只是一个绑定了执行环境的函数。
函数有作用域链，如果函数访问了上层作用域链上的变量，函数不销毁，变量不回收。

### 你知道现在有多少种函数吗？
* 第一种，普通函数：用 function 关键字定义的函数。
* 第二种，箭头函数：用 => 运算符定义的函数。
* 第三种，方法：在 class 中定义的函数。
* 第四种，生成器函数：用 function * 定义的函数。
* 第五种，类：用 class 定义的类，实际上也是函数。
* 第六 / 七 / 八种，异步函数：普通函数、箭头函数和生成器函数加上 async 关键字。

### this关键字？
this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。
调用函数时使用的引用，决定了函数执行时刻的 this 值。

### 为什么12.toString会报错？

> 文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。
> 词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”。
> JS中的词法分析中会得到的不同类型的token，JS语言特性中的一些特殊token需要根据语法分析并回传递标志来判断具体如何分词。
> token包括：空白符号 Whitespace、换行符 LineTerminator、注释 Comment、标识符名称 IdentifierName、符号 Punctuator、数字直接量 NumericLiteral、字符串直接量 StringLiteral、正则表达式直接量 RegularExpressionLiteral、字符串模板 Template

JavaScript中的 `.` (点)有两种含义，一种是代表一个小数，一种是调用方法。

12.toString() 会被解析成 12.（数字字面量） 和 toString()。（一个省略了小数后面部分的数字和一个方法）。



